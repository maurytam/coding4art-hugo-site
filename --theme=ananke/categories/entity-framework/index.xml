<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Entity Framework on Maurizio Tammacco&#39;s blog 4.0</title>
    <link>https://example.org/categories/entity-framework/</link>
    <description>Recent content in Entity Framework on Maurizio Tammacco&#39;s blog 4.0</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 12 Apr 2012 07:56:39 +0000</lastBuildDate><atom:link href="https://example.org/categories/entity-framework/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Entity Framework #3&amp;ndash;my scattered notes</title>
      <link>https://example.org/archive/2012/04/12/entity-framework-3ndashmy-scattered-notes.aspx</link>
      <pubDate>Thu, 12 Apr 2012 07:56:39 +0000</pubDate>
      
      <guid>https://example.org/archive/2012/04/12/entity-framework-3ndashmy-scattered-notes.aspx</guid>
      <description>When using Entity Framework 4.x Code First you can put your validation code in Data Annotations or inside the DbContext class (this is my preferred mode).
It’s possible to override the virtual method ValidateEntity exposed by the DbContext class and then define your own validation logic in one place.
This method is called once for each distinct entity being modified in your context, and it provides an opportunity for developers to stop the entity update process when some properties are in invalid state.</description>
    </item>
    
    <item>
      <title>Entity Framework #2&amp;ndash;my scattered notes Part 2</title>
      <link>https://example.org/archive/2012/03/29/entity-framework-2ndashmy-scattered-notes-part-2.aspx</link>
      <pubDate>Thu, 29 Mar 2012 08:02:46 +0000</pubDate>
      
      <guid>https://example.org/archive/2012/03/29/entity-framework-2ndashmy-scattered-notes-part-2.aspx</guid>
      <description>This is my second post about my Entity Framework Code First usage experience. You can find my first post here.
The Entity Framework Power Tool is a must-have tool for those who use EF in Code First mode, especially with fluent API. With this tool you can reverse-engineering an existing data source and then generate both domain classes (POCO) and the mapping configuration files. The latter are generated by creating a class which inherits from EntityConfiguration, where T is your domain entity type.</description>
    </item>
    
    <item>
      <title>Entity Framework #2&amp;ndash;my scattered notes Part 1</title>
      <link>https://example.org/archive/2012/03/22/entity-framework-2ndashmy-scattered-notes-part-1.aspx</link>
      <pubDate>Thu, 22 Mar 2012 16:05:38 +0000</pubDate>
      
      <guid>https://example.org/archive/2012/03/22/entity-framework-2ndashmy-scattered-notes-part-1.aspx</guid>
      <description>Here are a few scattered notes on the use of Entity Framework 4.2 Code First:
The core EF Api is contained in the System.Data.Entity.dll assembly The DbContext Object is a lightweight version of the ObjectContext object, the former provides more functionality than the first. If you need to get an ObjectContext instance starting from a DbContext instance you can use the IObjectContextAdapter interface for casting, as shown in the following example: The DbSet class is just a wrapper around the ObjectSet class A Complex Type has some limitations, the main are: a) it can expose only properties with primitive types b) it cannot be exposed as a multi-instance (collection) The EntityTypeConfiguration class has an interesting method called WillCascadeOnDelete(bool), whose name makes the idea of the action it takes.</description>
    </item>
    
    <item>
      <title>Entity Framework #1 &amp;ndash;How to get the original type of an entity when dynamic proxy is enabled</title>
      <link>https://example.org/archive/2012/03/13/entity-framework-1-ndashhow-to-get-the-original-type-of.aspx</link>
      <pubDate>Tue, 13 Mar 2012 16:09:51 +0000</pubDate>
      
      <guid>https://example.org/archive/2012/03/13/entity-framework-1-ndashhow-to-get-the-original-type-of.aspx</guid>
      <description>If your Entity Framework context is proxy-enabled, the runtime will create a proxy instance of your entities, i.e. a dynamically generated class which inherits from your entity class and overrides its virtual properties by inserting specific code useful for example for tracking changes and lazy loading.
The proxy instance has a dynamically generated name by the runtime that looks like this:
(User is the original entity class name which the proxy class inherited from).</description>
    </item>
    
    <item>
      <title>Visual Basic Tips &amp; Tricks Community Day a Milano</title>
      <link>https://example.org/archive/2010/03/19/visual-basic-tips-amp-tricks-community-day-a-milano.aspx</link>
      <pubDate>Fri, 19 Mar 2010 16:04:00 +0000</pubDate>
      
      <guid>https://example.org/archive/2010/03/19/visual-basic-tips-amp-tricks-community-day-a-milano.aspx</guid>
      <description>Ieri pomeriggio ho partecipato al Visual Basic Tips &amp;amp; Tricks Community Day tenutosi a Milano.
Devo dire che è stato un pomeriggio decisamente interessante dal punto di vista tecnologico, permettendomi di focalizzare alcuni concetti su tecnologie che uso o che vorrei usare, e mi riferisco a TFS 2010 ed Entity Framework 4.0
L’evento si apre con una sessione di Lorenzo Barbieri che parla delle varie versioni di Visual Studio 2010 che saranno disponibili a breve e delle novità, veramente tante, della nuova versione dell’IDE.</description>
    </item>
    
    <item>
      <title>Entity Framework &amp;ndash; Come impostare una relazione</title>
      <link>https://example.org/archive/2009/11/25/entity-framework-ndash-come-impostare-una-relazione.aspx</link>
      <pubDate>Wed, 25 Nov 2009 04:45:00 +0000</pubDate>
      
      <guid>https://example.org/archive/2009/11/25/entity-framework-ndash-come-impostare-una-relazione.aspx</guid>
      <description>Con Entity Framework è possibile referenziare tra loro entità in modo molto semplice.
Supponendo di avere l’entità Customer e l’entità Category, che rappresentano rispettivamente un cliente e la sua categoria di appartenenza, nel data model l’oggetto Customer conterrà una proprietà chiamata Category di tipo Category.
In fase di creazione di un nuovo oggetto Customer Ã¨ necessario associare la Category di appartenenza scelta dall’utente, molto probabilmente mediante una dropdown list contenente la lista delle categorie (DataTextField), e l’Id delle stesse (DataValueField).</description>
    </item>
    
  </channel>
</rss>
